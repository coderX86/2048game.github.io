# 2048 小游戏

[2048 在线试玩](https://hec9527.github.io/2048/src 'GitHub访问速度可能会比较慢,请耐心等待')

**<font color='#f67'>如果你对这个项目感兴趣的话，可以一起开发讨论并提出你宝贵的意见</font>**

**<font color='#f67'>同时如果可以的话请留下您的一颗小星星哦(～￣ ▽ ￣)～</font>**

&ensp; &ensp; &ensp;为了熟悉 GitHub 的使用,随手写了一个 2048，感觉这个游戏还是挺有意思的，还算是耐玩的一个小游戏 ,
因为网上这方面的开发教程或者说源代码也比较多，虽然写得不如那些大牛，但是至少是我自己写的

# 游戏逻辑的主要难点

-   每次移动之前需要判断是否可以移动
-   合并的时候不能连续合并

# 行列映射

> 向不同的方向移动的算法不同,如果我们为每一个方向上的移动以及判定是否可以移动都写一个方法,代码的冗余量太高,并且维护性太低  
> 所以我采用了一种映射的方式,将朝向不同方向移动的操作都转换为统一的移动操作,可以极大的降低代码的冗余  
> 具体操作为:  
> &ensp; &ensp; &ensp;我们移动的时候,一列一列的处理,例如向上移动,从第一列到最后一列,依次传递给`move`函数,这样每次移动的时候就只有 4 个方块,而`move`函数只需要设计成处理这种简单的移动就可以了,向其他方向移动类似

# 判断是否可以移动

> 判断是否可以移动也是采用行列映射的方式,依次处理每一行或者每一列,但是判定的关键是:  
> &ensp; &ensp; &ensp;当前的方块不为 0 且和下一个方块相等(两个不为 0 的相邻)  
> &ensp; &ensp; &ensp;当前当方块为 0 且下一个方块不为 0(非 0 方块前面有 0 方块)  
> 存在以上两种情况之一就判定可以移动

# 合并操作

> 同样使用行列映射  
> 一行一行或者一列一列的处理,具体操作有几种可能性,请看源代码`move`函数

# 版本更迭

## Alpha 版本

---

alpha 版本完成了游戏基本的逻辑  
存在问题:  
&ensp; &ensp; &ensp;在运行的过程中可以通过控制台修改游戏的变量

## release 版本

---

使用立即执行函数,拒绝非法修改游戏参数  
建立统一的事件监听函数

## release2.0 版本

---

优化了判定是否可以移动的算法，减少迭代次数  
优化了部分判断逻辑  
优化了监听函数的代码，减少重复代码  
更正了游戏结束后依然可以 排序 的 BUG  
修改了排序的算法，现在开始大的数字会放在左下角  
新增了部分函数的说明文档  
新增撤销上一步操作功能  
新增按钮不可用的样式

## release2.1 版本

---

修改了历史版本中可以修改 H5 代码修改游戏参数的 BUG
